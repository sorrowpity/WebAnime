<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3DåŠ¨ç”»æ¼”ç¤ºç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.75); /* æ›´æ·±çš„èƒŒæ™¯ */
            color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            max-height: calc(100vh - 20px);
            overflow-y: auto; /* å…è®¸æ»šåŠ¨ */
            width: 280px; /* å›ºå®šå®½åº¦ */
            box-sizing: border-box; /* åŒ…å«paddingåœ¨å†…çš„å®½åº¦ */
            z-index: 1000; /* ç¡®ä¿åœ¨æœ€ä¸Šå±‚ */
        }
        #ui h3 {
            margin-top: 0;
            color: #4CAF50;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }
        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #ADD8E6;
            font-size: 0.95em;
        }
        .control-group div label {
            font-weight: normal;
            font-size: 0.9em;
            color: #E0E0E0;
            margin-bottom: 4px;
        }
        input[type="range"] {
            width: calc(100% - 10px);
            margin-top: 5px;
            -webkit-appearance: none;
            height: 4px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        input[type="color"] {
            width: 80px;
            height: 25px;
            vertical-align: middle;
            border: none;
            padding: 0;
        }
        select, button, input[type="file"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #333;
            color: white;
            box-sizing: border-box;
            cursor: pointer;
            font-size: 0.9em;
        }
        button:hover {
            background-color: #555;
        }
        button.action-button {
            background-color: #4CAF50;
            border-color: #4CAF50;
            margin-top: 5px;
        }
        button.action-button:hover {
            background-color: #5cb85c;
        }
        .button-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap; /* å…è®¸æ¢è¡Œ */
        }
        .button-group button {
            flex-grow: 1; /* å‡åŒ€åˆ†å¸ƒ */
            width: auto; /* è¦†ç›–100% */
        }
        input[type="file"] {
            padding: 4px; /* æ–‡ä»¶è¾“å…¥æ¡†å¯èƒ½éœ€è¦è°ƒæ•´ */
            background-color: #2a2a2a;
        }
        .value-display {
            float: right;
            font-size: 0.8em;
            color: #BBB;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h3>ğŸš€ 3DåŠ¨ç”»æ¼”ç¤ºç³»ç»Ÿ ğŸš€</h3>
        
        <div class="control-group">
            <label>å‡ ä½•å»ºæ¨¡:</label>
            <select id="geometrySelector">
                <option value="cube">ç«‹æ–¹ä½“</option>
                <option value="sphere">çƒä½“</option>
                <option value="cylinder">åœ†æŸ±ä½“</option>
                <option value="torus">ç¯é¢ä½“</option>
                <option value="plane">å¹³é¢</option>
            </select>
            <label for="gltfModelInput">åŠ è½½GLTF/GLBæ¨¡å‹:</label>
            <input type="file" id="gltfModelInput" accept=".gltf,.glb">
        </div>
        
        <div class="control-group">
            <label>å‡ ä½•å˜æ¢:</label>
            <div>
                <label>Xä½ç½®: <span class="value-display" id="posX_val">0.0</span></label>
                <input type="range" id="posX" min="-5" max="5" step="0.1" value="0">
            </div>
            <div>
                <label>Yä½ç½®: <span class="value-display" id="posY_val">0.0</span></label>
                <input type="range" id="posY" min="-5" max="5" step="0.1" value="0">
            </div>
            <div>
                <label>Zä½ç½®: <span class="value-display" id="posZ_val">0.0</span></label>
                <input type="range" id="posZ" min="-5" max="5" step="0.1" value="0">
            </div>
            <div>
                <label>Xæ—‹è½¬: <span class="value-display" id="rotX_val">0Â°</span></label>
                <input type="range" id="rotX" min="0" max="360" step="1" value="0">
            </div>
            <div>
                <label>Yæ—‹è½¬: <span class="value-display" id="rotY_val">0Â°</span></label>
                <input type="range" id="rotY" min="0" max="360" step="1" value="0">
            </div>
            <div>
                <label>Zæ—‹è½¬: <span class="value-display" id="rotZ_val">0Â°</span></label>
                <input type="range" id="rotZ" min="0" max="360" step="1" value="0">
            </div>
            <div>
                <label>ç¼©æ”¾: <span class="value-display" id="scale_val">1.0</span></label>
                <input type="range" id="scale" min="0.1" max="5" step="0.05" value="1">
            </div>
        </div>
        
        <div class="control-group">
            <label>æè´¨ä¸çº¹ç†:</label>
            <div>
                <label>é¢œè‰²: <input type="color" id="colorPicker" value="#ff0000"></label>
            </div>
            <div>
                <label>é‡‘å±åº¦: <span class="value-display" id="metalness_val">0.0</span></label>
                <input type="range" id="metalness" min="0" max="1" step="0.05" value="0">
            </div>
            <div>
                <label>ç²—ç³™åº¦: <span class="value-display" id="roughness_val">0.5</span></label>
                <input type="range" id="roughness" min="0" max="1" step="0.05" value="0.5">
            </div>
            <div>
                <label>é€æ˜åº¦: <span class="value-display" id="opacity_val">1.0</span></label>
                <input type="range" id="opacity" min="0" max="1" step="0.05" value="1">
            </div>
            <label for="diffuseTextureInput">æ¼«åå°„çº¹ç†:</label>
            <input type="file" id="diffuseTextureInput" accept="image/*">
            <label for="normalMapInput">æ³•çº¿è´´å›¾:</label>
            <input type="file" id="normalMapInput" accept="image/*">
        </div>
        
        <div class="control-group">
            <label>å…‰ç…§æ§åˆ¶:</label>
            <div>
                <label>ç¯å¢ƒå…‰å¼ºåº¦: <span class="value-display" id="ambientIntensity_val">0.5</span></label>
                <input type="range" id="ambientIntensity" min="0" max="1" step="0.05" value="0.5">
            </div>
            <div>
                <label>æ–¹å‘å…‰å¼ºåº¦: <span class="value-display" id="dirIntensity_val">1.0</span></label>
                <input type="range" id="dirIntensity" min="0" max="5" step="0.1" value="1">
            </div>
            <div>
                <label>ç‚¹å…‰æºå¼ºåº¦: <span class="value-display" id="pointIntensity_val">0.8</span></label>
                <input type="range" id="pointIntensity" min="0" max="5" step="0.1" value="0.8">
            </div>
            <label for="pointLightX">ç‚¹å…‰æºX:</label>
            <input type="range" id="pointLightX" min="-10" max="10" step="0.5" value="0">
            <label for="pointLightY">ç‚¹å…‰æºY:</label>
            <input type="range" id="pointLightY" min="0" max="15" step="0.5" value="5">
            <label for="pointLightZ">ç‚¹å…‰æºZ:</label>
            <input type="range" id="pointLightZ" min="-10" max="10" step="0.5" value="0">
        </div>
        
        <div class="control-group">
            <label>è‡ªç”±å˜å½¢ (FFD):</label>
            <div class="button-group">
                <button id="createFFDPoints" class="action-button">åˆ›å»ºæ§åˆ¶ç‚¹</button>
                <button id="resetFFD">é‡ç½®å˜å½¢</button>
            </div>
            <p style="font-size:0.8em; color:#ccc; margin-top:10px;">(æ‹–æ‹½åœºæ™¯ä¸­çš„è“è‰²çƒä½“è¿›è¡Œå˜å½¢)</p>
        </div>
        
        <div class="control-group">
            <label>å…³é”®å¸§åŠ¨ç”»:</label>
            <div class="button-group">
                <button id="addKeyframe" class="action-button">æ·»åŠ å…³é”®å¸§</button>
                <button id="playAnim">æ’­æ”¾</button>
                <button id="pauseAnim">æš‚åœ</button>
                <button id="resetAnim">é‡ç½®</button>
                <button id="clearAnim">æ¸…é™¤æ‰€æœ‰</button>
            </div>
            <div style="margin-top: 10px;">
                <label>åŠ¨ç”»è¿›åº¦: <span class="value-display" id="animTime_val">0.0s</span></label>
                <input type="range" id="animationTimeline" min="0" max="10" step="0.01" value="0">
            </div>
        </div>
    </div>

    <!-- Three.js åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
    <!-- è½¨é“æ§åˆ¶å™¨ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
    <!-- GLTF/GLB æ¨¡å‹åŠ è½½å™¨ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- å¯è§†åŒ–è°ƒè¯•å·¥å…· (å¯é€‰) -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/libs/dat.gui.min.js"></script> -->

    <script>
        // --- 1. åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // å¯ç”¨é˜´å½±
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // æŸ”å’Œé˜´å½±
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        camera.position.set(0, 10, 20);
        controls.update();

        // --- æå‰å£°æ˜æ‰€æœ‰å¯èƒ½åœ¨åˆå§‹åŒ–æ—¶è¢«å¼•ç”¨çš„å…¨å±€å˜é‡ ---
        let currentObject = null; // å½“å‰æ“ä½œçš„3Då¯¹è±¡ (å¯ä»¥æ˜¯Meshæˆ–Group)
        let currentMesh = null; // å½“å‰æ“ä½œçš„Mesh (å¦‚æœæ˜¯GLTFï¼Œåˆ™æŒ‡å‘ç¬¬ä¸€ä¸ªMesh)
        let originalGeometry = null; // å­˜å‚¨åŸå§‹å‡ ä½•ä½“ç”¨äºFFDé‡ç½®
        const textureLoader = new THREE.TextureLoader();
        const gltfLoader = new THREE.GLTFLoader();

        let ffdControlPoints = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let draggableFFDPoint = null; // å½“å‰è¢«æ‹–æ‹½çš„FFDç‚¹

        let mixer = null;
        let animations = []; // å­˜å‚¨æ‰€æœ‰ AnimationClipï¼Œç›®å‰åªæœ‰ä¸€ä¸ªæ¨¡å‹æ‰€ä»¥åªç”¨ä¸€ä¸ª
        let animationAction = null; // ç¡®ä¿åœ¨ä»»ä½•å‡½æ•°è°ƒç”¨å®ƒä¹‹å‰å°±å·²å£°æ˜

        const clock = new THREE.Clock(); // ç”¨äºåŠ¨ç”»æ—¶é—´ç®¡ç†

        // --- 2. ç¯å…‰è®¾ç½® ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(5, 10, 7.5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 50;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);
        // scene.add(new THREE.DirectionalLightHelper(dirLight, 5)); // è°ƒè¯•ç”¨

        const pointLight = new THREE.PointLight(0xffffff, 0.8, 100); // é¢œè‰²ï¼Œå¼ºåº¦ï¼Œè·ç¦»
        pointLight.position.set(0, 5, 0);
        pointLight.castShadow = true;
        pointLight.shadow.mapSize.width = 512;
        pointLight.shadow.mapSize.height = 512;
        scene.add(pointLight);
        // scene.add(new THREE.PointLightHelper(pointLight, 1)); // è°ƒè¯•ç”¨

        // --- 3. ç¯å¢ƒè´´å›¾ (Environmental Mapping) ---
        const envLoader = new THREE.CubeTextureLoader();
        // ä¿®å¤ï¼šæ›´æ”¹ç¯å¢ƒè´´å›¾URLä»¥åŒ¹é…Three.jsç‰ˆæœ¬å¹¶ç¡®ä¿CDNè·¯å¾„æ­£ç¡®
        const envMapUrls = [
            'https://cdn.jsdelivr.net/npm/three@0.137.0/examples/textures/cube/Park3/posx.jpg',
            'https://cdn.jsdelivr.net/npm/three@0.137.0/examples/textures/cube/Park3/negx.jpg',
            'https://cdn.jsdelivr.net/npm/three@0.137.0/examples/textures/cube/Park3/posy.jpg',
            'https://cdn.jsdelivr.net/npm/three@0.137.0/examples/textures/cube/Park3/negy.jpg',
            'https://cdn.jsdelivr.net/npm/three@0.137.0/examples/textures/cube/Park3/posz.jpg',
            'https://cdn.jsdelivr.net/npm/three@0.137.0/examples/textures/cube/Park3/negz.jpg',
        ];
        const envMap = envLoader.load(envMapUrls);
        scene.environment = envMap; // è®¾ç½®å…¨å±€ç¯å¢ƒè´´å›¾
        const pointLightHelper = new THREE.PointLightHelper(pointLight, 1); // ç¬¬äºŒä¸ªå‚æ•°æ˜¯è¾…åŠ©å‡ ä½•ä½“çš„åŠå¾„
        scene.add(pointLightHelper);

        // --- 4. åœ°é¢ ---
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x336633,
            roughness: 0.7,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- 5. å‡ ä½•å»ºæ¨¡ä¸é€‰æ‹© ---
        function createPrimitive(type) {
            let geometry;
            switch(type) {
                case 'cube':
                    geometry = new THREE.BoxGeometry(5, 5, 5);
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(3, 64, 32); // æ›´å¤šåˆ†æ®µï¼Œæ›´å¹³æ»‘
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(2, 2, 6, 32);
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(3, 1, 32, 100);
                    break;
                case 'plane':
                    geometry = new THREE.PlaneGeometry(10, 10);
                    break;
                default:
                    geometry = new THREE.BoxGeometry(5, 5, 5);
                    break;
            }
            return geometry;
        }

        function createObject(type, isPrimitive = true) {
            if (currentObject) {
                scene.remove(currentObject);
                // æ¸…é™¤FFDæ§åˆ¶ç‚¹
                clearFFDControlPoints();
            }

            let newObject;
            let meshToOperate = null; // å®é™…è¿›è¡Œå˜æ¢ã€æè´¨ã€FFDæ“ä½œçš„Mesh

            if (isPrimitive) {
                const geometry = createPrimitive(type);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    metalness: 0,
                    roughness: 0.5,
                    transparent: false,
                    opacity: 1
                });
                newObject = new THREE.Mesh(geometry, material);
                meshToOperate = newObject;
                originalGeometry = geometry.clone(); // å…‹éš†ç”¨äºFFD
            } else { // GLTF/GLB Model
                // GLTFæ¨¡å‹åŠ è½½åœ¨loadGLTFModelä¸­å¤„ç†
                return;
            }

            newObject.castShadow = true;
            newObject.receiveShadow = true;
            scene.add(newObject);
            currentObject = newObject;
            currentMesh = meshToOperate; // æŒ‡å‘å®é™…æ“ä½œçš„ç½‘æ ¼
            updateUIFromObject(currentObject);
            resetAnimationState(); // æ›´æ¢æ¨¡å‹åé‡ç½®åŠ¨ç”»
        }

        function loadGLTFModel(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                gltfLoader.load(event.target.result, (gltf) => {
                    if (currentObject) {
                        scene.remove(currentObject);
                        clearFFDControlPoints();
                    }

                    const model = gltf.scene;
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            // å¯¹äºå¯¼å…¥çš„æ¨¡å‹ï¼Œé€šå¸¸éœ€è¦å°†å…¶BufferGeometryå…‹éš†ä¸€ä»½ä½œä¸ºåŸå§‹æ•°æ®
                            // å¹¶ä¸”ä¸ºäº†FFDèƒ½ç›´æ¥æ“ä½œé¡¶ç‚¹ï¼Œæœ€å¥½è½¬æ¢ä¸ºéç´¢å¼•çš„BufferGeometryæˆ–è€…Geometry
                            // æ³¨æ„ï¼šåœ¨GLTFåŠ è½½ä¸­ï¼ŒcurrentMeshå¯èƒ½æ˜¯ä¸€ä¸ªGroupæˆ–Sceneä¸­çš„ç¬¬ä¸€ä¸ªMesh
                            // è¿™æ®µé€»è¾‘éœ€è¦ç¡®ä¿ originalGeometry å’Œ currentMesh çš„ä¸€è‡´æ€§
                            if (!originalGeometry || (currentMesh && child.geometry !== originalGeometry)) { 
                                originalGeometry = child.geometry.clone();
                                // Ensure originalGeometry is non-indexed for easier direct vertex access
                                if (originalGeometry.index) {
                                    originalGeometry = originalGeometry.toNonIndexed();
                                }
                                originalGeometry.computeVertexNormals(); // Make sure normals are up to date
                            }
                            // å°†æè´¨æ›´æ–°ä¸ºStandardMaterialï¼Œå¹¶åº”ç”¨å½“å‰UIå€¼
                            child.material = new THREE.MeshStandardMaterial().copy(child.material);
                            if (!currentMesh) { // ç¡®ä¿åªèµ‹å€¼ä¸€æ¬¡ï¼Œå¦‚æœæ¨¡å‹æœ‰å¤šä¸ªMeshï¼Œæ“ä½œç¬¬ä¸€ä¸ª
                                currentMesh = child; 
                            }
                        }
                    });

                    scene.add(model);
                    currentObject = model; // æ•´ä¸ªæ¨¡å‹ä½œä¸ºå½“å‰å¯¹è±¡
                    // é€‚é…æ¨¡å‹å¤§å°ï¼Œé˜²æ­¢è¿‡å¤§æˆ–è¿‡å°
                    const bbox = new THREE.Box3().setFromObject(currentObject);
                    const size = bbox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scaleFactor = 5 / maxDim; // ç¼©æ”¾åˆ°æœ€å¤§å°ºå¯¸ä¸º5
                    currentObject.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    currentObject.position.set(0, 0, 0); // é‡ç½®ä½ç½®
                    updateUIFromObject(currentObject);
                    resetAnimationState(); // æ›´æ¢æ¨¡å‹åé‡ç½®åŠ¨ç”»
                }, undefined, (error) => {
                    console.error('Error loading GLTF model:', error);
                    alert('æ— æ³•åŠ è½½GLTFæ¨¡å‹ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æˆ–æ§åˆ¶å°é”™è¯¯ã€‚');
                });
            };
            reader.readAsDataURL(file); // è¯»å–æ–‡ä»¶ä¸ºData URL
        }


        // --- 6. UI æ›´æ–°ä¸äº‹ä»¶ç›‘å¬ ---
        const uiElements = {
            geometrySelector: document.getElementById('geometrySelector'),
            gltfModelInput: document.getElementById('gltfModelInput'),

            posX: document.getElementById('posX'),
            posY: document.getElementById('posY'),
            posZ: document.getElementById('posZ'),
            rotX: document.getElementById('rotX'),
            rotY: document.getElementById('rotY'),
            rotZ: document.getElementById('rotZ'),
            scale: document.getElementById('scale'),

            colorPicker: document.getElementById('colorPicker'),
            metalness: document.getElementById('metalness'),
            roughness: document.getElementById('roughness'),
            opacity: document.getElementById('opacity'),
            diffuseTextureInput: document.getElementById('diffuseTextureInput'),
            normalMapInput: document.getElementById('normalMapInput'),

            ambientIntensity: document.getElementById('ambientIntensity'),
            dirIntensity: document.getElementById('dirIntensity'),
            pointIntensity: document.getElementById('pointIntensity'),
            pointLightX: document.getElementById('pointLightX'),
            pointLightY: document.getElementById('pointLightY'),
            pointLightZ: document.getElementById('pointLightZ'),

            createFFDPoints: document.getElementById('createFFDPoints'),
            resetFFD: document.getElementById('resetFFD'),

            addKeyframe: document.getElementById('addKeyframe'),
            playAnim: document.getElementById('playAnim'),
            pauseAnim: document.getElementById('pauseAnim'),
            resetAnim: document.getElementById('resetAnim'),
            clearAnim: document.getElementById('clearAnim'),
            animationTimeline: document.getElementById('animationTimeline'),

            // Value displays
            posX_val: document.getElementById('posX_val'),
            posY_val: document.getElementById('posY_val'),
            posZ_val: document.getElementById('posZ_val'),
            rotX_val: document.getElementById('rotX_val'),
            rotY_val: document.getElementById('rotY_val'),
            rotZ_val: document.getElementById('rotZ_val'),
            scale_val: document.getElementById('scale_val'),
            metalness_val: document.getElementById('metalness_val'),
            roughness_val: document.getElementById('roughness_val'),
            opacity_val: document.getElementById('opacity_val'),
            ambientIntensity_val: document.getElementById('ambientIntensity_val'),
            dirIntensity_val: document.getElementById('dirIntensity_val'),
            pointIntensity_val: document.getElementById('pointIntensity_val'),
            animTime_val: document.getElementById('animTime_val')
        };

        // æ›´æ–°UIæ»‘å—çš„å€¼æ˜¾ç¤º
        function updateValueDisplays() {
            uiElements.posX_val.textContent = parseFloat(uiElements.posX.value).toFixed(1);
            uiElements.posY_val.textContent = parseFloat(uiElements.posY.value).toFixed(1);
            uiElements.posZ_val.textContent = parseFloat(uiElements.posZ.value).toFixed(1);
            uiElements.rotX_val.textContent = parseInt(uiElements.rotX.value) + 'Â°';
            uiElements.rotY_val.textContent = parseInt(uiElements.rotY.value) + 'Â°';
            uiElements.rotZ_val.textContent = parseInt(uiElements.rotZ.value) + 'Â°';
            uiElements.scale_val.textContent = parseFloat(uiElements.scale.value).toFixed(2);
            uiElements.metalness_val.textContent = parseFloat(uiElements.metalness.value).toFixed(2);
            uiElements.roughness_val.textContent = parseFloat(uiElements.roughness.value).toFixed(2);
            uiElements.opacity_val.textContent = parseFloat(uiElements.opacity.value).toFixed(2);
            uiElements.ambientIntensity_val.textContent = parseFloat(uiElements.ambientIntensity.value).toFixed(1);
            uiElements.dirIntensity_val.textContent = parseFloat(uiElements.dirIntensity.value).toFixed(1);
            uiElements.pointIntensity_val.textContent = parseFloat(uiElements.pointIntensity.value).toFixed(1);
        }

        // ä»3Då¯¹è±¡æ›´æ–°UIï¼ˆå½“æ¨¡å‹åˆ‡æ¢æˆ–åŠ¨ç”»æ’­æ”¾æ—¶ï¼‰
        function updateUIFromObject(obj) {
            if (!obj) return;

            uiElements.posX.value = obj.position.x.toFixed(1);
            uiElements.posY.value = obj.position.y.toFixed(1);
            uiElements.posZ.value = obj.position.z.toFixed(1);

            // æ¬§æ‹‰è§’è½¬å›åº¦æ•°
            const euler = new THREE.Euler().setFromQuaternion(obj.quaternion, 'XYZ');
            uiElements.rotX.value = THREE.MathUtils.radToDeg(euler.x).toFixed(0);
            uiElements.rotY.value = THREE.MathUtils.radToDeg(euler.y).toFixed(0);
            uiElements.rotZ.value = THREE.MathUtils.radToDeg(euler.z).toFixed(0);

            uiElements.scale.value = obj.scale.x.toFixed(2); // å‡è®¾XYZç¼©æ”¾ä¸€è‡´

            if (currentMesh && currentMesh.material) {
                uiElements.colorPicker.value = '#' + currentMesh.material.color.getHexString();
                uiElements.metalness.value = currentMesh.material.metalness !== undefined ? currentMesh.material.metalness.toFixed(2) : 0;
                uiElements.roughness.value = currentMesh.material.roughness !== undefined ? currentMesh.material.roughness.toFixed(2) : 0.5;
                uiElements.opacity.value = currentMesh.material.opacity !== undefined ? currentMesh.material.opacity.toFixed(2) : 1;
            }
            updateValueDisplays();
        }

        // åº”ç”¨UIå€¼åˆ°3Då¯¹è±¡
        function applyUIValuesToObject() {
            if (!currentObject) return;

            currentObject.position.set(
                parseFloat(uiElements.posX.value),
                parseFloat(uiElements.posY.value),
                parseFloat(uiElements.posZ.value)
            );
            currentObject.rotation.set(
                THREE.MathUtils.degToRad(parseFloat(uiElements.rotX.value)),
                THREE.MathUtils.degToRad(parseFloat(uiElements.rotY.value)),
                THREE.MathUtils.degToRad(parseFloat(uiElements.rotZ.value))
            );
            const scale = parseFloat(uiElements.scale.value);
            currentObject.scale.set(scale, scale, scale);

            if (currentMesh && currentMesh.material) {
                currentMesh.material.color.set(uiElements.colorPicker.value);
                currentMesh.material.metalness = parseFloat(uiElements.metalness.value);
                currentMesh.material.roughness = parseFloat(uiElements.roughness.value);
                currentMesh.material.opacity = parseFloat(uiElements.opacity.value);
                currentMesh.material.transparent = currentMesh.material.opacity < 1;
                currentMesh.material.needsUpdate = true;
            }
            updateValueDisplays();
        }

        function updateLightControls() {
            ambientLight.intensity = parseFloat(uiElements.ambientIntensity.value);
            dirLight.intensity = parseFloat(uiElements.dirIntensity.value);
            
            // æ›´æ–°ç‚¹å…‰æºå¼ºåº¦
            const pointIntensity = parseFloat(uiElements.pointIntensity.value);
            pointLight.intensity = pointIntensity;
            
            // æ›´æ–°ç‚¹å…‰æºä½ç½®
            pointLight.position.set(
                parseFloat(uiElements.pointLightX.value),
                parseFloat(uiElements.pointLightY.value),
                parseFloat(uiElements.pointLightZ.value)
            );
            
            
            // ä¿®å¤ï¼šæ›´æ–°ç‚¹å…‰æºé˜´å½±å‚æ•°ï¼ˆå¦‚æœéœ€è¦åŠ¨æ€è°ƒæ•´é˜´å½±åˆ†è¾¨ç‡ï¼‰
            pointLight.shadow.mapSize.width = 512;
            pointLight.shadow.mapSize.height = 512;
            
            updateValueDisplays();
        }

        // çº¹ç†åŠ è½½å‡½æ•°
        function loadTextureFile(file, type = 'map') {
            if (!currentMesh || !file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                textureLoader.load(event.target.result, (texture) => {
                    if (type === 'map') {
                        currentMesh.material.map = texture;
                    } else if (type === 'normalMap') {
                        currentMesh.material.normalMap = texture;
                        // æ³•çº¿è´´å›¾å¯èƒ½éœ€è¦åˆ‡çº¿
                        if (currentMesh.geometry.attributes.tangent === undefined) {
                            currentMesh.geometry.computeTangents();
                        }
                    }
                    currentMesh.material.needsUpdate = true;
                }, undefined, (error) => {
                    console.error('Error loading texture:', error);
                    alert('æ— æ³•åŠ è½½çº¹ç†ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æˆ–æ§åˆ¶å°é”™è¯¯ã€‚');
                });
            };
            reader.readAsDataURL(file);
        }

        // ç»‘å®šUIäº‹ä»¶
        Object.values(uiElements).forEach(element => {
            if (element.tagName === 'INPUT' && element.type === 'range') {
                element.addEventListener('input', applyUIValuesToObject);
                element.addEventListener('input', updateValueDisplays); // ç«‹å³æ›´æ–°æ˜¾ç¤º
                element.addEventListener('input', updateLightControls);
            } else if (element.tagName === 'INPUT' && element.type === 'color') {
                element.addEventListener('input', applyUIValuesToObject);
            } else if (element.id.startsWith('pointLight')) {
                element.addEventListener('input', updateLightControls);
            } else if (element.id.includes('Intensity')) {
                element.addEventListener('input', updateLightControls);
                element.addEventListener('input', updateValueDisplays);
            }
        });

        uiElements.geometrySelector.addEventListener('change', (e) => createObject(e.target.value));
        uiElements.gltfModelInput.addEventListener('change', (e) => loadGLTFModel(e.target.files[0]));
        uiElements.diffuseTextureInput.addEventListener('change', (e) => loadTextureFile(e.target.files[0], 'map'));
        uiElements.normalMapInput.addEventListener('change', (e) => loadTextureFile(e.target.files[0], 'normalMap'));

        // åˆå§‹åŒ–æ—¶è®¾ç½®UIæ˜¾ç¤º
        updateValueDisplays();
        updateLightControls();
        createObject('cube'); // åˆå§‹åŠ è½½ä¸€ä¸ªç«‹æ–¹ä½“

        // --- 7. è‡ªç”±å˜å½¢ (FFD - ç®€åŒ–å®ç°) ---
        function createFFDControlPoints() {
            clearFFDControlPoints(); // å…ˆæ¸…é™¤æ—§çš„

            if (!currentMesh || !originalGeometry) {
                alert('è¯·å…ˆåˆ›å»ºæˆ–åŠ è½½ä¸€ä¸ªæ¨¡å‹ï¼');
                return;
            }

            // ç¡®ä¿originalGeometryæ˜¯æœ€æ–°çš„ï¼Œå¦‚æœç”¨æˆ·é‡ç½®äº†å˜å½¢ï¼Œå¯èƒ½éœ€è¦é‡æ–°å…‹éš†
            if (currentMesh.geometry !== originalGeometry) {
                resetFFD(); // ç¡®ä¿å½“å‰å‡ ä½•ä½“æ˜¯åŸå§‹çŠ¶æ€
            }

            const bbox = new THREE.Box3().setFromObject(currentMesh);
            const size = bbox.getSize(new THREE.Vector3());
            const center = bbox.getCenter(new THREE.Vector3());

            const gridSize = 2; // ä¾‹å¦‚ï¼Œåˆ›å»ºä¸€ä¸ª 3x3x3 çš„æ§åˆ¶ç‚¹ç½‘æ ¼ (gridSize+1)
            const pointGeometry = new THREE.SphereGeometry(0.3, 16, 8);
            const pointMaterial = new THREE.MeshBasicMaterial({ color: 0x00BFFF, transparent: true, opacity: 0.8 });

            for (let i = 0; i <= gridSize; i++) {
                for (let j = 0; j <= gridSize; j++) {
                    for (let k = 0; k <= gridSize; k++) {
                        const x = center.x - size.x / 2 + (size.x / gridSize) * i;
                        const y = center.y - size.y / 2 + (size.y / gridSize) * j;
                        const z = center.z - size.z / 2 + (size.z / gridSize) * k;

                        const point = new THREE.Mesh(pointGeometry, pointMaterial);
                        point.position.set(x, y, z);
                        scene.add(point);
                        ffdControlPoints.push(point);

                        // å­˜å‚¨æ§åˆ¶ç‚¹è‡ªèº«çš„ä¸–ç•Œåˆå§‹ä½ç½®ï¼Œæ–¹ä¾¿è®¡ç®—delta
                        point.initialWorldPos = new THREE.Vector3().copy(point.position);
                    }
                }
            }

            // å¯ç”¨æ‹–æ‹½äº‹ä»¶
            renderer.domElement.addEventListener('pointerdown', onPointerDownFFD);
            renderer.domElement.addEventListener('pointermove', onPointerMoveFFD);
            renderer.domElement.addEventListener('pointerup', onPointerUpFFD);
            controls.enabled = false; // ç¦ç”¨è½¨é“æ§åˆ¶å™¨ï¼Œä»¥ä¾¿æ‹–æ‹½FFDç‚¹
        }

        function clearFFDControlPoints() {
            ffdControlPoints.forEach(p => scene.remove(p));
            ffdControlPoints = [];
            renderer.domElement.removeEventListener('pointerdown', onPointerDownFFD);
            renderer.domElement.removeEventListener('pointermove', onPointerMoveFFD);
            renderer.domElement.removeEventListener('pointerup', onPointerUpFFD);
            controls.enabled = true; // é‡æ–°å¯ç”¨è½¨é“æ§åˆ¶å™¨
        }

        function onPointerDownFFD(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(ffdControlPoints);

            if (intersects.length > 0) {
                draggableFFDPoint = intersects[0].object;
                controls.enabled = false; // ç¦ç”¨è½¨é“æ§åˆ¶å™¨
                // å­˜å‚¨é¼ æ ‡ç‚¹å‡»æ—¶çš„Zæ·±åº¦ï¼Œç”¨äºæ‹–æ‹½ä¿æŒæ·±åº¦
                const intersectPoint = intersects[0].point;
                draggableFFDPoint.offset = intersectPoint.sub(draggableFFDPoint.position);
            }
        }

        function onPointerMoveFFD(event) {
            if (draggableFFDPoint) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane();
                camera.getWorldDirection(plane.normal); // ä½¿ç”¨æ‘„åƒæœºæœå‘ä½œä¸ºå¹³é¢æ³•çº¿
                plane.setFromNormalAndCoplanarPoint(plane.normal, draggableFFDPoint.position); // å¹³é¢é€šè¿‡FFDç‚¹
                
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);
                
                if (intersectPoint) {
                    draggableFFDPoint.position.copy(intersectPoint.sub(draggableFFDPoint.offset));
                    applyFFD(); // æ‹–æ‹½æ—¶å®æ—¶æ›´æ–°å˜å½¢
                }
            } else {
                controls.enabled = true; // ç¡®ä¿æ²¡æœ‰æ‹–æ‹½æ—¶æ§åˆ¶å™¨å¯ç”¨
            }
        }

        function onPointerUpFFD() {
            draggableFFDPoint = null;
            controls.enabled = true; // é‡æ–°å¯ç”¨è½¨é“æ§åˆ¶å™¨
        }

        function applyFFD() {
            if (!currentMesh || !originalGeometry || ffdControlPoints.length === 0) return;

            // è·å–å½“å‰Meshçš„å‡ ä½•ä½“
            const geometryToDeform = currentMesh.geometry;
            const originalPositions = originalGeometry.attributes.position.array;
            const deformedPositions = new Float32Array(originalPositions.length); // åˆ›å»ºæ–°çš„æ•°ç»„

            // å˜å½¢å½±å“èŒƒå›´å’Œè¡°å‡
            const influenceRadius = 10; // FFDæ§åˆ¶ç‚¹çš„å½±å“èŒƒå›´
            const influenceFalloff = 2; // è¡°å‡æŒ‡æ•°ï¼Œè¶Šå¤§è¡°å‡è¶Šå¿«

            for (let i = 0; i < originalPositions.length; i += 3) {
                const originalLocalVertex = new THREE.Vector3(
                    originalPositions[i],
                    originalPositions[i+1],
                    originalPositions[i+2]
                );
                // å°†åŸå§‹å±€éƒ¨é¡¶ç‚¹è½¬æ¢ä¸ºä¸–ç•Œåæ ‡ï¼Œä»¥ä¾¿ä¸FFDæ§åˆ¶ç‚¹æ¯”è¾ƒè·ç¦»
                const originalWorldVertex = originalLocalVertex.clone();
                currentObject.localToWorld(originalWorldVertex);

                let totalInfluenceDelta = new THREE.Vector3(); // ç´¯ç§¯çš„å˜å½¢é‡
                let totalWeight = 0; // ç´¯ç§¯çš„æƒé‡

                ffdControlPoints.forEach(controlPoint => {
                    // æ§åˆ¶ç‚¹çš„ä¸–ç•Œä½ç½®
                    const cpWorldPos = controlPoint.position;
                    // æ§åˆ¶ç‚¹çš„åŸå§‹ä¸–ç•Œä½ç½®
                    const cpInitialWorldPos = controlPoint.initialWorldPos;

                    // è®¡ç®—æ§åˆ¶ç‚¹çš„å®é™…ç§»åŠ¨é‡ï¼ˆä¸–ç•Œåæ ‡ï¼‰
                    const cpDelta = cpWorldPos.clone().sub(cpInitialWorldPos);

                    // è®¡ç®—é¡¶ç‚¹åˆ°æ§åˆ¶ç‚¹çš„è·ç¦»
                    const dist = originalWorldVertex.distanceTo(cpInitialWorldPos);

                    if (dist < influenceRadius) {
                        // è®¡ç®—æƒé‡ï¼ˆåŸºäºè·ç¦»çš„è¡°å‡ï¼‰
                        const normalizedDist = dist / influenceRadius;
                        const weight = Math.pow(1 - normalizedDist, influenceFalloff); // æ›´å¹³æ»‘çš„è¡°å‡
                        
                        totalInfluenceDelta.addScaledVector(cpDelta, weight);
                        totalWeight += weight;
                    }
                });

                let newWorldVertex = originalWorldVertex.clone();
                if (totalWeight > 0) {
                    newWorldVertex.add(totalInfluenceDelta.divideScalar(totalWeight));
                }

                // å°†å˜å½¢åçš„ä¸–ç•Œé¡¶ç‚¹è½¬æ¢å›æ¨¡å‹å±€éƒ¨åæ ‡
                currentObject.worldToLocal(newWorldVertex);
                
                deformedPositions[i] = newWorldVertex.x;
                deformedPositions[i+1] = newWorldVertex.y;
                deformedPositions[i+2] = newWorldVertex.z;
            }

            // æ›´æ–°å‡ ä½•ä½“çš„positionå±æ€§
            currentMesh.geometry.setAttribute('position', new THREE.BufferAttribute(deformedPositions, 3));
            currentMesh.geometry.attributes.position.needsUpdate = true;
            currentMesh.geometry.computeVertexNormals(); // é‡æ–°è®¡ç®—æ³•çº¿
            // currentMesh.geometry.computeTangents(); // å¦‚æœæœ‰æ³•çº¿è´´å›¾ï¼Œå¯èƒ½éœ€è¦é‡æ–°è®¡ç®—åˆ‡çº¿
        }


        function resetFFD() {
            clearFFDControlPoints();
            if (currentMesh && originalGeometry) {
                currentMesh.geometry.dispose(); // é‡Šæ”¾æ—§å‡ ä½•ä½“èµ„æº
                currentMesh.geometry = originalGeometry.clone(); // æ¢å¤åˆ°åŸå§‹å‡ ä½•ä½“
                currentMesh.geometry.computeVertexNormals();
                // currentMesh.geometry.computeTangents(); // ç¡®ä¿åˆ‡çº¿ä¹Ÿé‡ç½®
            }
        }

        uiElements.createFFDPoints.addEventListener('click', createFFDControlPoints);
        uiElements.resetFFD.addEventListener('click', resetFFD);

        // --- 8. å…³é”®å¸§åŠ¨ç”» ---
        function recordKeyframe() {
            if (!currentObject) return;

            // è·å–å½“å‰æ—¶é—´
            const currentTime = mixer ? mixer.time : 0;

            const position = currentObject.position.clone();
            const quaternion = currentObject.quaternion.clone();
            const scale = currentObject.scale.clone();

            let foundExistingClip = false;
            if (animations.length > 0) {
                // å¦‚æœå·²ç»æœ‰åŠ¨ç”»ç‰‡æ®µï¼Œå°è¯•æ·»åŠ åˆ°ç°æœ‰ç‰‡æ®µä¸­
                const existingClip = animations[0]; // å‡è®¾åªæœ‰ä¸€ä¸ªæ¨¡å‹çš„åŠ¨ç”»

                // æ£€æŸ¥å¹¶æ›´æ–°æˆ–æ·»åŠ position track
                let posTrack = existingClip.tracks.find(t => t.name === '.position');
                if (!posTrack) {
                    posTrack = new THREE.VectorKeyframeTrack('.position', [], []);
                    existingClip.tracks.push(posTrack);
                }
                posTrack.times.push(currentTime);
                posTrack.values.push(position.x, position.y, position.z);

                // æ£€æŸ¥å¹¶æ›´æ–°æˆ–æ·»åŠ quaternion track
                let rotTrack = existingClip.tracks.find(t => t.name === '.quaternion');
                if (!rotTrack) {
                    rotTrack = new THREE.QuaternionKeyframeTrack('.quaternion', [], []);
                    existingClip.tracks.push(rotTrack);
                }
                rotTrack.times.push(currentTime);
                rotTrack.values.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);

                // æ£€æŸ¥å¹¶æ›´æ–°æˆ–æ·»åŠ scale track
                let scaleTrack = existingClip.tracks.find(t => t.name === '.scale');
                if (!scaleTrack) {
                    scaleTrack = new THREE.VectorKeyframeTrack('.scale', [], []);
                    existingClip.tracks.push(scaleTrack);
                }
                scaleTrack.times.push(currentTime);
                scaleTrack.values.push(scale.x, scale.y, scale.z);

                // å¯¹trackè¿›è¡Œæ’åºï¼Œç¡®ä¿æ—¶é—´è½´æ­£ç¡®
                posTrack.sort();
                rotTrack.sort();
                scaleTrack.sort();

                existingClip.duration = Math.max(existingClip.duration, currentTime);
                foundExistingClip = true;
            }

            if (!foundExistingClip) {
                // å¦‚æœæ²¡æœ‰åŠ¨ç”»ç‰‡æ®µï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„
                const tracks = [
                    new THREE.VectorKeyframeTrack('.position', [currentTime], [position.x, position.y, position.z]),
                    new THREE.QuaternionKeyframeTrack('.quaternion', [currentTime], [quaternion.x, quaternion.y, quaternion.z, quaternion.w]),
                    new THREE.VectorKeyframeTrack('.scale', [currentTime], [scale.x, scale.y, scale.z])
                ];
                const clip = new THREE.AnimationClip('MainAnimation', currentTime, tracks);
                animations.push(clip);
            }
            
            // æ›´æ–°æ—¶é—´è½´æœ€å¤§å€¼
            if (animations.length > 0) {
                uiElements.animationTimeline.max = animations[0].duration + 1; // å¢åŠ ä¸€ç‚¹ä½™é‡
            }
            console.log('å…³é”®å¸§å·²æ·»åŠ :', animations);
        }

        function setupAnimationMixer() {
            if (currentObject && !mixer) {
                mixer = new THREE.AnimationMixer(currentObject);
                mixer.addEventListener('finished', onAnimationFinished);
            }
        }

        function playAnimation() {
            if (!currentObject || animations.length === 0) {
                alert('è¯·å…ˆæ·»åŠ å…³é”®å¸§ï¼');
                return;
            }

            setupAnimationMixer();
            if (animationAction) {
                animationAction.play();
                animationAction.paused = false;
            } else {
                animationAction = mixer.clipAction(animations[0]);
                animationAction.loop = THREE.LoopRepeat; // å¾ªç¯æ’­æ”¾
                animationAction.clampWhenFinished = false;
                animationAction.play();
            }
            clock.start(); // å¼€å§‹è®¡æ—¶å™¨
            updateValueDisplays(); // ç¡®ä¿æ˜¾ç¤ºæ›´æ–°
        }

        function pauseAnimation() {
            if (animationAction) {
                animationAction.paused = true;
                clock.stop(); // åœæ­¢è®¡æ—¶å™¨
            }
        }

        function resetAnimation() {
            if (animationAction) {
                animationAction.stop(); // åœæ­¢å¹¶é‡ç½®åˆ°ç¬¬ä¸€å¸§
                mixer.stopAllAction();
                // æ¢å¤åˆ°åˆå§‹çŠ¶æ€ï¼ˆå…³é”®å¸§0ï¼‰
                if (animations.length > 0 && animations[0].tracks.length > 0) {
                    const firstPos = new THREE.Vector3(
                        animations[0].tracks.find(t => t.name === '.position')?.values[0] || 0,
                        animations[0].tracks.find(t => t.name === '.position')?.values[1] || 0,
                        animations[0].tracks.find(t => t.name === '.position')?.values[2] || 0
                    );
                    const firstRot = new THREE.Quaternion(
                        animations[0].tracks.find(t => t.name === '.quaternion')?.values[0] || 0,
                        animations[0].tracks.find(t => t.name === '.quaternion')?.values[1] || 0,
                        animations[0].tracks.find(t => t.name === '.quaternion')?.values[2] || 0,
                        animations[0].tracks.find(t => t.name === '.quaternion')?.values[3] || 1
                    );
                    const firstScale = new THREE.Vector3(
                        animations[0].tracks.find(t => t.name === '.scale')?.values[0] || 1,
                        animations[0].tracks.find(t => t.name === '.scale')?.values[1] || 1,
                        animations[0].tracks.find(t => t.name === '.scale')?.values[2] || 1
                    );
                    currentObject.position.copy(firstPos);
                    currentObject.quaternion.copy(firstRot);
                    currentObject.scale.copy(firstScale);
                    updateUIFromObject(currentObject);
                }
            }
            uiElements.animationTimeline.value = 0;
            uiElements.animTime_val.textContent = '0.0s';
            clock.stop(); // ç¡®ä¿è®¡æ—¶å™¨åœæ­¢
        }

        function clearAnimation() {
            if (animationAction) { // æ£€æŸ¥ animationAction æ˜¯å¦å·²å®šä¹‰
                animationAction.stop();
                if (mixer) { // æ£€æŸ¥ mixer æ˜¯å¦å·²å®šä¹‰
                    mixer.uncacheRoot(mixer.getRoot()); // æ¸…é™¤æ‰€æœ‰ä¸æ ¹å¯¹è±¡ç›¸å…³çš„ç¼“å­˜
                }
                mixer = null;
                animationAction = null;
            }
            animations = [];
            uiElements.animationTimeline.value = 0;
            uiElements.animationTimeline.max = 10; // é‡ç½®æœ€å¤§å€¼
            uiElements.animTime_val.textContent = '0.0s';
            // æ¢å¤æ¨¡å‹åˆ°UIæ§åˆ¶çš„åˆå§‹çŠ¶æ€
            applyUIValuesToObject();
            clock.stop(); // ç¡®ä¿è®¡æ—¶å™¨åœæ­¢
        }
        
        // åŠ¨ç”»æ’­æ”¾å®Œæˆåå›è°ƒ
        function onAnimationFinished() {
            // å¯ä»¥é€‰æ‹©åœæ­¢æˆ–å¾ªç¯ï¼Œè¿™é‡Œè®¾ä¸ºå¾ªç¯
            // console.log('Animation finished, looping...');
        }

        function resetAnimationState() {
            clearAnimation(); // ç§»é™¤æ‰€æœ‰å…³é”®å¸§å’ŒåŠ¨ç”»çŠ¶æ€
            applyUIValuesToObject(); // å°†æ¨¡å‹æ¢å¤åˆ°UIå½“å‰è®¾ç½®çš„çŠ¶æ€
        }

        uiElements.addKeyframe.addEventListener('click', recordKeyframe);
        uiElements.playAnim.addEventListener('click', playAnimation);
        uiElements.pauseAnim.addEventListener('click', pauseAnimation);
        uiElements.resetAnim.addEventListener('click', resetAnimation);
        uiElements.clearAnim.addEventListener('click', clearAnimation);
        
        uiElements.animationTimeline.addEventListener('input', (e) => {
            if (mixer && animations.length > 0) {
                mixer.stopAllAction(); // åœæ­¢å½“å‰æ’­æ”¾çš„åŠ¨ç”»
                animationAction = mixer.clipAction(animations[0]);
                animationAction.time = parseFloat(e.target.value); // è®¾ç½®åˆ°æŒ‡å®šæ—¶é—´
                animationAction.play(); // æ’­æ”¾åŠ¨ç”»
                animationAction.paused = true; // ç«‹å³æš‚åœï¼Œå®ç°æ‰‹åŠ¨æ‹–åŠ¨æ•ˆæœ
                updateUIFromObject(currentObject); // æ›´æ–°UIæ˜¾ç¤º
                uiElements.animTime_val.textContent = parseFloat(e.target.value).toFixed(1) + 's';
            }
        });


        // --- 9. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta(); // è·å–å¸§é—´éš”æ—¶é—´

            controls.update(); // æ›´æ–°è½¨é“æ§åˆ¶å™¨

            if (mixer) {
                mixer.update(delta); // æ›´æ–°åŠ¨ç”»æ··åˆå™¨
                // æ›´æ–°æ—¶é—´è½´æ»‘å—
                if (animationAction && !animationAction.paused) { // åªæœ‰åœ¨æ’­æ”¾æ—¶æ‰æ›´æ–°æ—¶é—´
                    uiElements.animationTimeline.value = mixer.time;
                    uiElements.animTime_val.textContent = mixer.time.toFixed(1) + 's';
                }
                // æ›´æ–°UIæ˜¾ç¤ºï¼Œå› ä¸ºåŠ¨ç”»ä¼šæ”¹å˜æ¨¡å‹çŠ¶æ€
                updateUIFromObject(currentObject);
            }
            
            renderer.render(scene, camera);
        }

        animate();

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
